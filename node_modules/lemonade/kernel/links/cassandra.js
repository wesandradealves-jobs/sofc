/**
 * Cassandra loader script
 * @return {Cassandra}
 */

function cassandraLoader () {}

/**
 * Default hosts
 * @type {object}
 */
cassandraLoader.prototype.hosts;

/**
 * Default options
 * @type {object}
 */
cassandraLoader.prototype.options;

/**
 * Last used keyspace
 * @type {string}
 */
cassandraLoader.prototype.lastkeyspace;

/**
 * References to adaptors (a new adaptor is
 * created for each unique keyspace)
 * @type {{}}
 */
cassandraLoader.prototype.adaptors = {};

/**
 * Load
 * @param {array} hosts
 * @param {string} keyspace
 * @param {object} options
 * @param {function} callback
 */
cassandraLoader.prototype.load = function(hosts, keyspace, options, callback) {

    if (!hosts && !keyspace) {
		throw new Error(
			'Cassandra missing config. Define hosts/user/pass/keyspace in the configuration file'
		);
	}

    var nodes = [], cluster;

    for (var key in hosts) {
        nodes.push(hosts[key].host + ':' + hosts[key].port);
    }

    cluster = {
         hosts   : nodes
        ,options : options
    };

    this.lastkeyspace = keyspace;
    this.hosts        = hosts;
    this.options      = options;

    this.adaptors[keyspace] = this.kernel.include(this.kernel.kerneldir + 'adaptors/cassandra').singleton(
         keyspace
        ,cluster
        ,keyspace
    );

    if (Object.keys(this.adaptors).length > 1) {
        callback();
    } else {
        callback(null, '- cassandra `' + keyspace + '` pool up');
    }

};

/**
 * Return a singleton for the adaptor based on keyspace (there will be a
 * different connection pool and adaptor object for each keyspace name used)
 * @param {string} keyspace
 * @param {function} callback
 */
cassandraLoader.prototype.link = function(keyspace, callback) {
	keyspace = keyspace || this.lastkeyspace;
	if (!this.adaptors || !this.adaptors[keyspace]) {
        this.load(this.hosts, keyspace, this.options, function(err) {
            if (err) {
                var error = new Error('Failed to load cassandra adaptor : ' + err.message);
                this.kernel.error(error);
                callback(error);
            } else {
                callback(null, this.adaptors[keyspace]);
            }
        }.bind(this));
    } else {
        callback(null, this.adaptors[keyspace]);
	}
};

/**
 * Gather up statuses from all open adaptors
 * @return {object}
 */
cassandraLoader.prototype.status = function() {
	var merge = {};
	for (var keyspace in this.adaptors) {
		merge[keyspace] = this.adaptors[keyspace].status;
	}
	return merge;
};

/**
 * Unload all adaptors (prepare for shutdown)
 * @param {function} cb
 */
cassandraLoader.prototype.unload = function(cb) {
	var noloaded = Object.keys(this.adaptors).length;
	if (!noloaded) {
		cb(null, 'pool not created');
	} else {
		for (var keyspace in this.adaptors) {
			this.adaptors[keyspace].shutdown(function() {

                delete this.adaptors[keyspace];

				if (!--noloaded) {
					cb(null, 'pool drained');
				}
			}.bind(this));
		}
	}
};

/**
 * Export
 */
exports = module.exports = cassandraLoader;