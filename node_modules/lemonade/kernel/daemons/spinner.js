/******************************************************************************
 * Lemonade JS
 * https://lemonadejs.com
 *
 * ----
 *
 * Spinner
 *
 *  A simple daemon that loops and runs scripts from appdir/intervals/. Creates
 *  a custom instance object which will echo and log inside the logpath, each
 *  script having its own logfile for stdout and stderr
 *
 * @param {function} callback
 *
 *****************************************************************************/

function Spinner (callback) {
    this._fetchintervals(function(error) {
        if (error) {
            callback(error);
        } else {
            this._intv = setInterval(this._run.bind(this), this.speed);
            callback();
        }
    }.bind(this));
}

/**
 * Module dependencies
 */
var fs = require('fs');

/**
 * Spinner loop time in ms
 * @type {number}
 * @private
 */
Spinner.prototype.speed = 1000;

/**
 * List of intervals (as read from the interval dir)
 * @type {}
 * @private
 */
Spinner.prototype._intervals = {};

/**
 * Running intervals
 * @type {}
 * @private
 */
Spinner.prototype._running = {};

/**
 * Last loop time
 * @type {number}
 * @private
 */
Spinner.prototype._lastrun = 0;

/**
 * Created instances since startup
 * @type {number}
 * @private
 */
Spinner.prototype._count = 0;

/**
 * Internal loop interval id
 * @type {number}
 * @private
 */
Spinner.prototype._intv;

/**
 * Overloaded instance prototype
 * @type {}
 * @private
 */
Spinner.prototype._instance;

/**
 * Log prefix (+ additional prefix by kernel.log). All intervals
 * will have output and error logs
 */
Spinner.prototype._logprefix = 'interval';

/**
 * If debug mode activated, spinner will output verbose messages
 * to debug-spinner.log
 * @type {string}
 * @private
 */
Spinner.prototype._debugfile = 'spinner.debug';

/**
 * Status object
 * @return {}
 */
Spinner.prototype.status = function() {
    return {
         speed   : this.speed + 'ms'
        ,lastrun : this._lastrun ?
            this.kernel.utility.date('yyyy-mm-dd HH:ii:ss', this._lastrun) : 0
        ,count   : this._count
        ,running : this._running
        ,pending : this._intervals
    };
};

/**
 * Stop the spinner loop and wait for running
 * processes to end
 * @param {function} cb
 */
Spinner.prototype.shutdown = function(cb) {
    clearInterval(this._intv);
    var wait = setInterval(function() {
        if (!Object.keys(this._running).length) {
            clearInterval(wait);
            cb();
        } else {
            /**
             * Loop over internal intervals and apply end to each interval
             */
            for (var key in this._running) {
                this._running[key].obj.end();
            }
        }
    }.bind(this), 1000);
};

/**
 * Load intervals from the app dir
 * @param {function} callback
 */
Spinner.prototype._fetchintervals = function(callback) {
    var dir = this.kernel.appdir + this.kernel.config._KERNEL_DIR_INTERVALS + '/';
    fs.readdir(dir, function(err, files) {
        if (err) {
            callback(
                new Error('Spinner error : couldn\'t read intervals from : ' + dir)
            );
        } else {
            this.kernel.debug(
                'read intervals dir (' + dir + '): \n' + files
                , this._debugfile
            );
            /**
             * Load each interval
             */
            for (var i = 0, max = files.length; i < max; i++) {

                var  name = files[i].replace('.js','')
                    ,cls  = this.kernel.include(dir + name).module;

                this._intervals[name] = {
                     active        : cls.active
                    ,maxinstances  : cls.instances
                    ,instances     : 0
                    ,name          : name
                };
            }
            callback();
        }
    }.bind(this));
};

/**
 * Go through the scanned intervals and run them
 */
Spinner.prototype._run = function() {
    /**
     * Last run time
     */
    this._lastrun = this.kernel.utility.microtime();
    /**
     * Overload the instance object
     */
    if (!this._instance) {
        this._instance = this.kernel.include(this.kernel.kerneldir + 'instance')
                       . extends(this.instancereloaded);
    }
    /**
     * Loop and run
     */
    for (var name in this._intervals) {
        var interval = this._intervals[name];
        /**
         * If the interval is active and hasn't reached
         * max running instances, run it again
         */
        this.kernel.debug(
            'will try to run interval : ' + interval.name + ' - instances : '
             + interval.instances + ' / ' + interval.maxinstances
            , this._debugfile
        );
        if (interval.active && interval.instances < interval.maxinstances) {
            /**
             * Tick the internal counter
             */
            this._count++;
            /**
             * Create an Instance object - needed or loading
             * the interval module
             */
            var instanceobj = this._instance.new();
            instanceobj.id = 'interval-' + this._count;
            this.kernel.debug(
                  'spawned spinner instance (for ' + interval.name + '): ' + instanceobj.id
                , this._debugfile
            );
            /**
             * Include the interval
             */
            var intvclass = instanceobj.interval(interval.name);
            /**
             * Interval name
             * @private
             */
            instanceobj.name = interval.name;
            /**
             * Interval log file prefix
             * @private
             */
            instanceobj._log = this._logprefix + '-' + interval.name;
            /**
             * Reference back to the spinner
             * @private
             */
            instanceobj._spinner = this;
            /**
             * Status info
             */
            this._running[instanceobj.id] = {
                 'id'    : instanceobj.id
                ,'name'  : instanceobj.name
                ,'start' : instanceobj.starttime
                ,'obj'   : null
            };
            /**
             * Increment open instances on the interval class
             */
            this._intervals[instanceobj.name].instances++;
            /**
             * Check for schedule method
             */
            if ((typeof intvclass.module.schedule === 'function' && intvclass.module.schedule()) ||
                 typeof intvclass.module.schedule !== 'function') {
                /**
                 * Run the interval
                 */
                this._running[instanceobj.id]['obj'] = instanceobj;
                intvclass.new();
            } else {
                /**
                 * If not scheduled we can't construct the interval
                 * so the end method won't get called...so call it
                 * and detach the instance
                 */
                instanceobj.end();
            }
        }
    }
};

/**
 * Placeholder
 */
Spinner.prototype.instancereloaded = function() {};

/**
 * Echo to the output log
 * @param {string} message
 */
Spinner.prototype.instancereloaded.echo = function(message) {
    this.log(message);
};

/**
 * Echo to the error log
 * @param {string|Error} message
 */
Spinner.prototype.instancereloaded.error = function(message) {
    this.kernel.log(
         message
        ,this._log + '.err'
    );
};

/**
 * Echo to the output log
 * @param {string} message
 */
Spinner.prototype.instancereloaded.log = function(message) {
    this.kernel.log(
         message
        ,this._log + '.out'
    );
};

/**
 * Echo to the output or error log and mark the instance
 * as completed (remove it from the status object and free
 * a slot for another instance of this class to be started)
 * @param {string|Error} error
 * @param {string} message
 */
Spinner.prototype.instancereloaded.end = function(error, message) {
    this.kernel.debug(
        'closing spinner instance : ' + this.id
        , this._spinner._debugfile
    );
    if (error) {
        this.error(error);
    } else if (message) {
        this.log(message);
    }
    /**
     * Delete from running instances
     */
    delete this._spinner._running[this.id];
    /**
     * Decrement instances for the interval class
     */
    this._spinner._intervals[this.name].instances--;
};

/**
 * Exports
 */
exports = module.exports = Spinner;