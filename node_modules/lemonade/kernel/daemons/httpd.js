/******************************************************************************
 * Lemonade JS
 * https://lemonadejs.com
 *
 * ----
 *
 * HTTP Daemon
 *
 *  Each HTTP request will create a new Instance object, attach http specific
 *  properties to it and do a URI based routing inside the controllers dir
 *
 *  Each controller will emit via Instance the usual action events (log, error,
 *  output, end) + two additional : flush and header
 *
 * @param {number} port
 *
 *****************************************************************************/

function Httpd (port) {
    this.port = port || 1337;
    this._server();
}

/**
 * Module dependencies
 */
var  httplib    = require('http')
    ,url        = require('url')
    ,qs         = require('qs')
    ,util       = require('util')
    ,formidable = require('formidable');

/**
 * Event emitted when the httpd daemon is up
 * and listening for requests
 * @type {string}
 */
Httpd.prototype.ONLINE = 'httpd-online';

/**
 * Event emitted when the daemon is down
 * @type {string}
 */
Httpd.prototype.OFFLINE = 'httpd-offline';

/**
 * Httpd port
 * @type {number}
 */
Httpd.prototype.port = 80;

/**
 * Status
 * @return {{running: {}, count: number, port: *}}
 */
Httpd.prototype.status = {
     running : {}
    ,count   : 0
    ,port    : this.port
};

/**
 * Internal server reference
 * @private
 */
Httpd.prototype._server;

/**
 * Idle connection timeout
 * @type {number}
 */
Httpd.prototype.timeout = 4000;

/**
 * Log file names (will be prefixed by kernel.log)
 * @private
 */
Httpd.prototype._accesslog = 'http.access';
Httpd.prototype._errorlog  = 'http.error';
Httpd.prototype._debuglog  = 'http.debug';

/**
 * Overloaded instance prototype
 * @type {}
 * @private
 */
Httpd.prototype._instanceproto;

/**
 * Gracefully shutdown the server. All connections
 * will wait for httpd.timeout before closing
 * @param {function} cb
 */
Httpd.prototype.shutdown = function(cb) {
    this._server.close(function(err) {
        this.kernel.emit(this.OFFLINE);
        cb(err);
    }.bind(this));
};

/**
 * Creates the actual http server and defines the logic
 * behind request handling
 * @private
 * @return
 */
Httpd.prototype._server = function() {
    this._server = httplib.createServer(function(req, res) {
        this._handlerequest(req, res);
    }.bind(this))
    /**
     * Start listening for requests
     */
    .listen(this.port);
    /**
     * Emit when ready
     */
    this._server.addListener('listening', function() {
        this.kernel.emit(this.ONLINE);
    }.bind(this));
    /**
     * Modify connection timeout
     */
    this._server.addListener('connection',function(stream) {
        stream.setTimeout(this.timeout);
    }.bind(this));
};

/**
 * Prepare get and post objects and create an Instance object
 * @param req
 * @param res
 * @private
 */
Httpd.prototype._handlerequest = function(req, res) {
    /**
     * Handle and parse GET data
     */
    var gett = qs.parse(req.url.substring(req.url.indexOf('?') + 1));
    /**
     * Multipart POST
     */
    if (req.method.toLowerCase() === 'post' && req.headers['content-type'] &&
        req.headers['content-type'].toLowerCase().indexOf('multipart') !== -1) {
        var form = new formidable.IncomingForm();
        form.parse(req, function (err, fields, files) {
            /**
             * Merge post fields in a single object
             */
            var merged = {};
            for (var key in fields) {
                merged[key] = fields[key];
            }
            for (var key in files) {
                merged[key] = files[key];
            }
            /**
             * Merge var[] var[key] into arrays and objects
             */
            var post = {};
            for (var key in merged) {
                if (key.indexOf('[') !== -1 && key.indexOf(']') !== -1) {
                    var   nkey = key.substring(key.indexOf('[') + 1, key.indexOf(']'))
                        , objk = key.substring(0, key.indexOf('['));
                    if (!post[objk]) {
                        post[objk] = {};
                    }
                    post[objk][nkey] = merged[key];
                } else {
                    post[key] = merged[key];
                }
            }
            for (var key in post) {
                if (typeof post[key] === 'object') {
                    var all = true;
                    for (var ikey in post[key]) {
                        if (!this.kernel.utility.isNumber(ikey)) {
                            all = false;
                        }
                    }
                    if (all) {
                        var arr = [];
                        for (var ikey in post[key]) {
                            arr.push(post[key][ikey]);
                        }
                        post[key] = arr;
                    }
                }
            }
            this._instance(req, res, gett, post);
        }.bind(this));
        /**
         * Change duplicate names that contain [] (arrays)
         * into unique keys so they can be transformed into arrays
         * later on
         */
        var arrparts = {};
        form.onPart = function(part) {
            if (part.name.indexOf('[]') !== -1) {
                if (typeof arrparts[part.name] === 'undefined') {
                    arrparts[part.name] = 0;
                }
                part.name = part.name.replace('[]', '[' + arrparts[part.name]++ + ']')
            }
            form.handlePart(part);
        }
    }
    /**
     * Normal or no POST
     */
    else {
        var post = ''; req.on('data', function (chunk) {
            post += chunk.toString();
        });
        req.on('end', function () {
            /**
             * Automate json parsing if the raw post
             * is a json encoded string
             */
            if (post) {
                try {
                    post = JSON.parse(post);
                } catch (e) {
                    post = qs.parse(post);
                }
            }
            this._instance(req, res, gett, post);
        }.bind(this));
    }
};

/**
 * Create a new Instance object for each request (overloaded with
 * http specific properties and methods)
 * @private
 * @param {*} req
 * @param {*} res
 * @param {*} gett
 * @param {*} post
 */
Httpd.prototype._instance = function (req, res, gett, post) {
    /**
     * Overload the instance with our instance reloaded
     */
    if (!this._instanceproto) {
        this._instanceproto = this.kernel.include(this.kernel.kerneldir + 'instance')
                            . extends(this.instancereloaded);
    }
    var instanceobj = this._instanceproto.new();
    instanceobj.id  = 'http-' + this.status.count;
    this.kernel.debug(
        'spawned http instance : ' + instanceobj.id
        , this._debuglog
    );
    /**
     * Bind http request and response
     */
    instanceobj.request  = req;
    instanceobj.response = res;
    /**
     * get / post shortcuts
     */
    instanceobj.get  = gett;
    instanceobj.post = post;
    /**
     * Internals
     */
    instanceobj._outputbuffer = '';
    instanceobj._httpserver   = this;
    instanceobj._header       = { code: 200, entries: {'Content-type': 'text/json'} };
    instanceobj._headersent   = false;
    instanceobj._flushed      = false;
    /**
     * Override the instance id to be http specific
     */
    this.status.count++;
    /**
     * Status info
     */
    this.status.running[instanceobj.id] = {
         id     : instanceobj.id
        ,req    : instanceobj.request.url
        ,start  : this.kernel.utility.date('yyyy-mm-dd HH:ii:ss', instanceobj.starttime)
        ,method : instanceobj.request.method
        ,ip     : instanceobj.request.connection.remoteAddress
    };
    /**
     * Route the request to the appropriate controller
     */
    instanceobj.route();
};

/**
 * Placeholder
 */
Httpd.prototype.instancereloaded = function() {};

/**
 * Route the request to the appropriate controller based
 * on URI. Only first dir applies, then that controller must
 * handle routing from there.
 */
Httpd.prototype.instancereloaded.route = function() {

    var  arr  = url.parse(this.request.url).pathname.split('/')
        ,def  = 'default'
        ,path = def;

    if (arr[1]) {
        path = arr[1];
    }

    /**
     * Try to load the module, if not found
     * will throw
     */
    try {
        this.controller(path).new();
    } catch (err) {
        /**
         * Module not found, this is 404
         */
        if (err.code === 'MODULE_NOT_FOUND') {
            this.end(
                new Error('Invalid route')
            );
        } else {
            this.end(err);
        }
    }
};

/**
 * Mark the instance as ended, flush if needed and remove from
 * the internal scoreboard. Log to the appropriate file depending
 * on error
 * @param {string|Error} error
 * @param {string} data
 */
Httpd.prototype.instancereloaded.end = function(error, data) {
    this.kernel.debug(
        'closing http instance : ' + this.id
        , this._httpserver._debuglog
    );
    /**
     * Flush the output if not flushed
     */
    if (!this._flushed) {
        this.flush(error, data);
    }
    /**
     * Remove the instace from the status object
     */
    delete this._httpserver.status.running[this.id];
    /**
     * Log information
     */
    var  duration = ((this.kernel.utility.microtime()
                    - this.kernel.utility.microtime(this.starttime)) / 1000) || 0
        ,logmsg   = (this.request.headers['x-forwarded-for'] || this.request.connection.remoteAddress) + ' '
                  +  this.request.method + ' '
                  +  this.request.url + ' '
                  +  duration.toFixed(3) + 's';
    if (error) {
        this.kernel.log(logmsg + ' ' + error, this._httpserver._errorlog, this.starttime);
    } else {
        this.kernel.log(logmsg, this._httpserver._accesslog, this.starttime);
    }
};

/**
 * Flush the buffer (or data) via http.response and end the
 * response. Send the headers if not sent.
 * @param {string|Error} error
 * @param {*} data
 */
Httpd.prototype.instancereloaded.flush = function(error, data) {
    /**
     * Fetch the message if we got an error
     */
    if (error instanceof Error) {
        error = error.message;
    }
    /**
     * Merge current data with our buffer
     */
    if (data && this._outputbuffer) {
        this._outputbuffer += data;
    } else if (data) {
        this._outputbuffer  = data;
    }
    /**
     * Send headers
     */
    if (!this._headersent) {
        this.header();
    }
    /**
     * Depending on the content type, try to format our response
     */
    if (this._header.entries['Content-type'] === 'text/json') {
        var duration = ((this.kernel.utility.microtime() - this.starttime) / 1000) || 0;
        this.response.write(
            JSON.stringify({
                 'error'    : !!error
                ,'duration' : duration
                ,'response' : (error) ? error : this._outputbuffer
            }, null, 4)
        );
    } else {
        this.response.write(
            (error || this._outputbuffer) + ''
        );
    }
    /**
     * End the instance
     */
    this.response.end();
    this._flushed = true;
};

/**
 * Sends the http headers and response code
 * @param {number} code
 * @param {object} entries
 */
Httpd.prototype.instancereloaded.header = function(code, entries) {
    if (entries) {
        this._header.entries = entries;
    }
    if (code) {
        this._header.code = code;
    }
    this._headersent = true;
    this.response.writeHead(this._header.code, this._header.entries);
};

/**
 * Append data to the outputbuffer
 * @param {string} output
 */
Httpd.prototype.instancereloaded.echo = function(output) {
    this._outputbuffer += output;
};

/**
 * Log a message to the http error log
 * @param {string|Error} object
 */
Httpd.prototype.instancereloaded.error = function(object) {
    this.kernel.log(object, this._errorlog);
};

/**
 * Log a message to the http log
 * @param {string} message
 */
Httpd.prototype.instancereloaded.log = function(message) {
    this.kernel.log(message, this._accesslog);
};

/**
 * Exports
 */
exports = module.exports = Httpd;