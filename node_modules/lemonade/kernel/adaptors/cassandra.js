/*****************************************************************************
 * Lemonade JS
 * https://lemonadejs.com
 *
 * ----
 *
 * Cassandra
 *
 *  Adaptor to connect and execute queries on a Cassandra cluster. Uses pool
 *  connections.
 *
 *****************************************************************************/

/**
 * Module dependencies
 */
var adaptor = require('helenus');

/**
 * Cassandra
 *
 * @param {object] cluster
 * @param {string} keyspace
 * @constructor
 */
function Cassandra(cluster, keyspace) {

    /**
     * Cassandra pool
     * @type {*}
     * @private
     */
    this._pool = new adaptor.ConnectionPool({
         hosts            : cluster.hosts
        ,user             : cluster.options.user              || ''
        ,pass             : cluster.options.pass              || ''
        ,cqlVersion       : cluster.options.cql_version       || this.DEFAULT_CQL_VERSION
        ,hostPoolSize     : cluster.options.pool_size         || this.DEFAULT_POOL_SIZE
        ,consistencylevel : cluster.options.consistency_level || this.DEFAULT_CONSISTENCY_LEVEL
        ,keyspace         : keyspace
    });

    /**
     * Record slow queries if they take longer then this parameter in milliseconds
     * @type {integer}
     * @private
     */
    this._query_slow = cluster.options.slow || this.DEFAULT_QUERY_SLOW;

    /**
     * Set consistency level for this keyspace for old cql version (2.x)
     * @type {string}
     */
    if (this._pool.cqlVersion == '2.0.0') {
        this._consistency_insert = cluster.options.consistency_insert || this.CONSISTENCY_LOCAL_QUORUM;
        this._consistency_select = cluster.options.consistency_select || this.CONSISTENCY_LOCAL_QUORUM;
        this._consistency_update = cluster.options.consistency_update || this.CONSISTENCY_LOCAL_QUORUM;
        this._consistency_delete = cluster.options.consistency_delete || this.CONSISTENCY_LOCAL_QUORUM;
        this._consistency_batch  = cluster.options.consistency_batch  || this.CONSISTENCY_LOCAL_QUORUM;
    }

    /**
     * Connect to cassandra pool
     * @type {*}
     * @private
     */
    this._pool.connect(function(error) {
        if (error) {
            this.kernel.emit(this.ERROR);
        } else {
            this.kernel.emit(this.CONNECTED);
        }
    }.bind(this));

    this._pool.on('error', function(error) {
        this.kernel.debug(error.name + ' ' + error.message, this._debugfile);
    }.bind(this));
}

/**
 * Connection events
 * @type {string}
 */
Cassandra.prototype.CONNECTED    = 'cassandra-connected';
Cassandra.prototype.DISCONNECTED = 'cassandra-disconnected';
Cassandra.prototype.ERROR        = 'cassandra-error';

/**
 * Status object
 */
Cassandra.prototype.status = {
     querycnt : 0
    ,running  : {}
};

/**
 * Connection pool
 */
Cassandra.prototype._pool;

/**
 * Mark query as slow after threshold
 */
Cassandra.prototype._query_slow;

/**
 * Consistency properties for each query type
 * @type {string}
 */
Cassandra.prototype._consistency_insert;
Cassandra.prototype._consistency_select;
Cassandra.prototype._consistency_update;
Cassandra.prototype._consistency_delete;
Cassandra.prototype._consistency_batch;

/**
 * Consistency constants
 * @type {string}
 */
Cassandra.prototype.CONSISTENCY_ONE          = 'ONE';
Cassandra.prototype.CONSISTENCY_QUORUM       = 'QUORUM';
Cassandra.prototype.CONSISTENCY_LOCAL_QUORUM = 'LOCAL_QUORUM';
Cassandra.prototype.CONSISTENCY_EACH_QUORUM  = 'EACH_QUORUM';
Cassandra.prototype.CONSISTENCY_ALL          = 'ALL';
Cassandra.prototype.CONSISTENCY_ANY          = 'ANY';
Cassandra.prototype.CONSISTENCY_TWO          = 'TWO';
Cassandra.prototype.CONSISTENCY_THREE        = 'THREE';

Cassandra.prototype.DEFAULT_POOL_SIZE         = 10;
Cassandra.prototype.DEFAULT_QUERY_SLOW        = 1;//seconds
Cassandra.prototype.DEFAULT_CQL_VERSION       = '2.0.0';
Cassandra.prototype.DEFAULT_CONSISTENCY_LEVEL = 3;

/**
 * Debug file
 * @type {string}
 * @private
 */
Cassandra.prototype._debugfile = 'cassandra.debug';

/**
 * Cassandra slow query log
 * @type {string}
 * @private
 */
Cassandra.prototype._slowlogfile = 'cassandra.slow';

/**
 * Executes a query on Cassandra Cluster
 *
 * @param {string} query
 * @param {array} params
 * @param {function} callback
 */
Cassandra.prototype.query = function(query, params, callback) {

    if (typeof query === 'undefined') {
        callback(new Error('Missing query'));
    } else if (typeof params === 'undefined') {
        callback(new Error('Missing binds'));
    } else {

        /**
         * Add the query to the status object
         */
        var  query_id       = Math.floor(Math.random() * 10000)
            ,query_start    = this.kernel.utility.microtime()
            ,query_duration = 0
            ,query_log      = '';

        this.status.querycnt++;
        this.status.running[query_id] = {
             query  : query
            ,params : params
            ,start  : this.kernel.utility.date('yyyy-mm-dd HH:ii:ss')
        };

        /**
         * Set the consistency for this query
         */
        if (this._pool.cqlVersion == '2.0.0') {
            query = this.setConsistency(query);
        }

        this._pool.cql(query, params, function(error, results) {

            /*
             * Log all queries above query_slow parameter for debugging
             */
            query_duration = (this.kernel.utility.microtime() - query_start) / 1000;
            query_log = query_duration.toFixed(3) + 's | ' + JSON.stringify(this.status.running[query_id]);

            if (query_duration >= this._query_slow) {
                this.kernel.log(query_log, this._slowlogfile);
            }

            this.kernel.debug(query_log, this._debugfile);

            if (error) {
                callback(error);
            } else {

                callback(null, results);

                /**
                 * Remove the query from the status object
                 */
                delete this.status.running[query_id];
            }
        }.bind(this));
    }
};

/**
 * Add consistency for each query type
 *
 * @param {string} query
 * @return {string}
 */
Cassandra.prototype.setConsistency = function(query) {

    /**
     * Check if consistency already set in the query
     */
    if (query.toLowerCase().indexOf('consistency') != -1) {
        return query;
    }

    var hasWhere = query.toLowerCase().indexOf('where') != -1 ? true : false;
    var hasUsing = query.toLowerCase().indexOf('using') != -1 ? true : false;

    /**
     * Add consistency to batch queries
     */
    if (query.toLowerCase().indexOf('batch') != -1) {

        if (hasUsing) {
            return query.replace(
                 /USING\s+TIMESTAMP\s+(.*?)\s+/i
                ,'USING TIMESTAMP $1 AND CONSISTENCY ' + this._consistency_batch + ' '
            );
        }

        return query.replace(/batch/i, 'BATCH USING CONSISTENCY ' + this._consistency_batch);
    }

    /**
     * Add consistency to select queries
     */
    if (query.toLowerCase().indexOf('select') != -1) {

        if (hasWhere) {
            if (hasUsing) {
                return query.replace(/where/i, 'AND CONSISTENCY ' + this._consistency_select + ' WHERE');
            }

            return query.replace(/where/i, 'USING CONSISTENCY ' + this._consistency_select + ' WHERE');
        }

        if (hasUsing) {
            return query + ' AND CONSISTENCY ' + this._consistency_select;
        }

        return query + ' USING CONSISTENCY ' + this._consistency_select;
    }

    /**
     * Add consistency to insert queries
     */
    if (query.toLowerCase().indexOf('insert') != -1) {

        if (hasUsing) {
            return query + ' AND CONSISTENCY ' + this._consistency_insert;
        }

        return query + ' USING CONSISTENCY ' + this._consistency_insert;
    }

    /**
     * Add consistency to update queries
     */
    if (query.toLowerCase().indexOf('update') != -1) {

        if (hasUsing) {
            return query.replace(/set/i, 'AND CONSISTENCY ' + this._consistency_update + ' SET');
        }

        return query.replace(/set/i, 'USING CONSISTENCY ' + this._consistency_update + ' SET');
    }

    /**
     * Add consistency to delete queries
     */
    if (query.toLowerCase().indexOf('delete') != -1) {

        if (hasWhere) {
            if (hasUsing) {
                return query.replace(/where/i, 'AND CONSISTENCY ' + this._consistency_delete + ' WHERE');
            }

            return query.replace(/where/i, 'USING CONSISTENCY ' + this._consistency_delete + ' WHERE');
        }

        if (hasUsing) {
            return query + ' AND CONSISTENCY ' + this._consistency_delete;
        }

        return query + ' USING CONSISTENCY ' + this._consistency_delete;
    }

    /**
     * Ignore consistency for other queries types(eg: ALTER, CREATE, DROP)
     */
    return query;
};

/**
 * Shutting down the pool prevents further work from being enqueued,
 * and closes all open connections after pending requests are complete.
 * @param {function} callback
 */
Cassandra.prototype.shutdown = function(callback) {
    this._pool.close();
    callback();
};

/**
 * Exports
 */
exports = module.exports = Cassandra;