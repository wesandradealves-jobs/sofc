/*****************************************************************************
 * Lemonade JS
 * https://lemonadejs.com
 *
 * ----
 *
 * Rabbit
 *
 *  Adaptor to connect to Rabbitmq. Subscribe to a queue and have messages
 *  pushed. Publish messages. Creates a connection pool using generic-pool.
 *
 * @param {Object} config
 *
 *****************************************************************************/

function Rabbit (config) {
    /**
     * Prepare config
     */
    if (typeof config !== 'object') {
        config = { host : config };
    }
    this.config = config;
    this.config.defaultExchangeName = "";
    /**
     * Create the pool
     */
    this._poolup();
}

/**
 * Module dependencies
 */
var   amqp = require('amqp')
    , pool = require('generic-pool')
    , util = require('util');

/**
 * Config
 * @type {object}
 */
Rabbit.prototype.config = {
      host      : 'localhost'
    , port      :  5672
    , login     : 'guest'
    , password  : 'guest'
    , vhost     : '/'
};

/**
 * Amqp connection pool
 * @type {object}
 * @private
 */
Rabbit.prototype._pool;

/**
 * References to open connections
 * @type {object}
 * @private
 */
Rabbit.prototype._openconns = {};

/**
 * Debugfile
 * @type {string}
 * @private
 */
Rabbit.prototype._debugfile = 'rabbit.debug';

/**
 * Create generic pool
 * @private
 */
Rabbit.prototype._poolup = function() {
    this._pool = pool.Pool({
          name              : 'rabbitmq'
        , max               : 10
        , min               : 2
        , log               : this._log.bind(this)
        , idleTimeoutMillis : 30000
        /**
         * Create a new internal connection object
         */
        , create : function (cb) {
            var
            conn            = new RabbitConnection();
            conn.config     = this.config;
            conn.kernel     = this.kernel;
            conn._debugfile = this._debugfile;
            conn.open(function() {
                cb(null, conn);
            });
        }.bind(this)
        /**
         * Release and end the connection
         */
        , destroy : function (conn) {
            if (conn) {
                conn.close();
            }
        }.bind(this)
    });
};

/**
 * Status object
 * @returns {{}}
 */
Rabbit.prototype.status = function() {
    var status = {
        pool : {
              size      : this._pool.getPoolSize()
            , available : this._pool.availableObjectsCount()
            , waiting   : this._pool.waitingClientsCount()
        } ,
        connections : {}
    };
    for (var key in this._openconns) {
        status.connections[key] = {
             subscribed : this._openconns[key]._subscribed
            ,published  : this._openconns[key]._prepared
        };
    }
    return status;
};

/**
 * Acquire a connection from the pool, attaches this._pool
 * for the release method
 */
Rabbit.prototype.connection = function(cb) {
    try {
        this._pool.acquire(function(err, conn) {
            this._openconns[conn.id] = conn;
            conn.parent = this;
            cb(err, conn);
        }.bind(this));
    } catch(err) {
        cb(new Error('Failed to acquire rabbit connection reason: ' + err.message));
    }
};

/**
 * Gracefully end all active (released connections)
 * @param {function} cb
 */
Rabbit.prototype.shutdown = function(cb) {
    for (var key in this._openconns) {
        var conn = this._openconns[key];
        this._pool.release(conn);
        delete this._openconns[conn.id];
    }
    this._pool.drain(function() {
        this._pool.destroyAllNow();
        cb();
    }.bind(this));
};

/**
 * Logs messages from the generic pool
 * @param {string} message
 * @param {string} level
 * @private
 */
Rabbit.prototype._log = function(message, level) {
    if (level === 'error') {
        this.kernel.error(
            new Error('Rabbit generic pool error : ' + message)
        );
    } else {
        this.kernel.debug(
            'Rabbit generic pool : ' + message
            , this._debugfile
        );
    }
};

/**
 * Rabbit connection
 * @private
 */
function RabbitConnection () {
    this.id = Math.random();
}

/**
 * Connection id
 * @type {number}
 */
RabbitConnection.prototype.id;

/**
 * Kernel reference
 * @type {object}
 */
RabbitConnection.prototype.kernel;

/**
 * Config reference
 * @type {object}
 */
RabbitConnection.prototype.config;

/**
 * Parent reference (needed for releasing connections from
 * the generic pool)
 * @type {object}
 * @private
 */
RabbitConnection.prototype.parent;

/**
 * Rabbitmq connection
 * @type {object}
 * @private
 */
RabbitConnection.prototype._conn;

/**
 * Prepared queues
 * @type {{}}
 * @private
 */
RabbitConnection.prototype._prepared = {};

/**
 * Subscribed queues
 * @type {{}}
 * @private
 */
RabbitConnection.prototype._subscribed = {};

/**
 * Prefetch count
 * @type {number}
 * @private
 */
RabbitConnection.prototype._prefetch = 10;

/**
 * Queue init params (todo : make this configurable)
 * @type {{}}
 * @private
 */
RabbitConnection.prototype._qparams = {
    autoDelete : false, durable : true
};

/**
 * Opens the connection
 */
RabbitConnection.prototype.open = function(cb) {
    this._conn = amqp.createConnection(this.config);
    this._conn.once('ready', cb);
};

/**
 * Closes the connection
 */
RabbitConnection.prototype.close = function() {
    this.unsubscribe(null, function() {});
    this._conn.end();
};

/**
 * Releases the connection to be used again in the pool
 */
RabbitConnection.prototype.release = function() {
    this.unsubscribe(null, function() {});
    this.parent._pool.release(this);
    delete this.parent._openconns[this.id];
};

/**
 * Subscribe to a queue. Will receive messages as they are published. Instant ack.
 * @param {string} queue
 * @param {function} callbackfetch
 * @param {function} callbacksubscribe
 */
RabbitConnection.prototype.subscribe = function(queue, callbackfetch, callbacksubscribe) {
    this._conn.queue(queue, this._qparams , function(q) {
        /**
         * Mark queue as prepared (needed for publishing)
         */
        this._prepared[queue] = {
             queue     : queue
            ,published : 0
        };
        q.subscribe({ ack : true, prefetchCount : this._prefetch }, function (message, headers, deliveryInfo) {
            this.kernel.debug('got message from subscribed queue ' + queue, this._debugfile);
            /**
             * Increment no. of fetched messages for this queue
             */
            if (typeof this._subscribed[queue] !== 'undefined') {
                this._subscribed[queue].fetched++;
            }
            /**
             * If the message retrieved is and object, transform it to string
             */
            callbackfetch(null, (typeof message.data !== 'undefined') ? message.data.toString() : message);
            /**
             * Move to the next message
             */
            q.shift();
        }.bind(this)).addCallback(function(ok) {
            this.kernel.debug('subcribed to queue : ' + queue, this._debugfile);
            /**
             * Keep the consumer tag for debugging
             */
            if (typeof this._subscribed[queue] === 'undefined') {
                this._subscribed[queue] = {
                     queue   : queue
                    ,tag     : ok.consumerTag
                    ,active  : true
                    ,fetched : 1
                    ,objq    : q
                };
            } else {
                this._subscribed[queue].active = true;
                this._subscribed[queue].tag    = ok.consumerTag;
            }
            callbacksubscribe(ok);
        }.bind(this));
    }.bind(this));
};

/**
 * Unsubscribe from a queue
 * @param {string} queue
 * @param {function} callback
 */
RabbitConnection.prototype.unsubscribe = function(queue, callback) {
    if (queue) {
        if (typeof this._subscribed[queue] !== 'undefined' &&
            this._subscribed[queue].active) {
            this._subscribed[queue].objq.unsubscribe(this._subscribed[queue].tag);
            this._subscribed[queue].objq.close();
            this._subscribed[queue].active = false;
        }
    } else {
        for (var key in this._subscribed) {
            this.unsubscribe(key, function() {});
        }
    }
    callback();
};

/**
 * Publish message to queue
 * @param {string} queue
 * @param {string} message
 * @param {function} callback
 */
RabbitConnection.prototype.publish = function(queue, message, callback) {
    this.kernel.debug('publishing message to ' + queue + ' : ' +
                       util.inspect(message), this._debugfile);
    if (typeof this._prepared[queue] === 'undefined') {
        /**
         * Initiate a connection to the queue first to create it if it's not
         * already there
         */
        this._conn.queue(queue, { autoDelete : false, durable : true }, function() {
            this._conn.publish(queue, message);
            this._prepared[queue] = {
                 queue     : queue
                ,published : 1
            };
            callback();
        }.bind(this));
    } else {
        this._conn.publish(queue, message);
        this._prepared[queue].published++;
        callback();
    }
};

/**
 * Export
 */
exports = module.exports = Rabbit;